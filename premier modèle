import numpy as np
import random
import matplotlib.pyplot as plt

delta = 0.95
b_0 = 1

class Graphe:

    def __init__(self, agents=[], b_0=b_0, delta=delta):
        self.agents = agents
        self.graphe = dict([( i, [[],[], b_0] ) for i in agents]) 
        #self.graphe a la structure suivante:
        # {i:[[liste des agents j auquels i a prêté :  i --> j],
        #     [liste des agents j qui ont prêté à i : i <-- j ],
        #     Le montant cash que possède i : b0]}
        self.nb_agents = len(agents)
        self.nb_relations = 0

        l , b = 0 , 0
        for i in self.agents:
            l = l + len(self.graphe[i][1])
            b = b + len(self.graphe[i][0]) + self.graphe[i][2]

        self.liabilities = l 
        self.assets = b

    def ajout_relation(self, i, j): # i prête à j   
        self.graphe[i][0].append(j) # j devient un emprunteur de i
        self.graphe[j][1].append(i) # i devient un prêteur de i 
        self.graphe[i][2] = self.graphe[i][2] - delta 
        self.graphe[j][2] = self.graphe[j][2] + delta
        self.nb_relations = self.nb_relations + 1
    
    def invest_reussi(self, i, j): # Le prêt donné par i à j arrive à maturité
        self.graphe[i][0].remove(j) # j n'est plus un emprunteur de i
        self.graphe[j][1].remove(i) # i n'est plus un prêteur de i 
        self.graphe[i][2] = self.graphe[i][2] + 1 # Le prêt est remboursé
        self.graphe[j][2] = self.graphe[j][2] -1
        self.nb_relations = self.nb_relations - 1

    def foreclose(self, i , j): # i décide de foreclose le prêt qu'il a donné à j 
        self.graphe[i][0].remove(j) # j n'est plus un emprunteur de i
        self.graphe[j][1].remove(i) # i n'est plus un prêteur de i
        self.nb_relations = self.nb_relations - 1 

def arete(graphe):
    """description: une foction qui retourne la liste des aretes à partir du graphe
    ----input:graphe qui représente notre réseau
    ----output: liste des aretes de ce graphe """
    aretes=[]
    for element in graphe.keys():
        for voisin in graphe[element][0]:
            if (element,voisin) not in aretes:
                aretes.append((element,voisin))
    return  aretes
# On génère un état initial aléatoire

N = 500
agents = [i for i in range(N)]
G = Graphe(agents, b_0, delta)
for i in agents:
    J = random.randint(1,N) # J est le nombre des agents j auquels i va prêter : i --> j
    k=random.random()
    for j in random.choices(agents, k=J): 
        if j==i:
            continue
        else:
            if G.graphe[i][2] >= delta: # i doit avoir au moins delta pour pouvoir prêter
                G.ajout_relation(i,j)
#print(len(arete(G.graphe)))
         
def dynamique (G, c, gamma,lamda,nu,durée):

    t=0
    temps=[]
    liste_de_connectivité=[]
    nb_arretes_initiale=len(arete(G.graphe))

    while t<=durée:
        

        liste_de_connectivité.append(len(arete(G.graphe)))
        temps.append(t)
        
        t=t+1        
        for i in G.agents:
            k=random.random()
            p = random.random() # p est nombre aléatoire entre 0 et 1
            j = random.randint(0,len(G.agents)-1) # j est un agent aléatoire du graphe
            
            if (j != i) and (j not in G.graphe[i][1]) and (G.graphe[j][2]>=delta) :
                #je vérifie que l'élément alétoire qu'on vient de choisir est différent de l'element qui se traite, et que cet element alétoire n'a pas déja emprunté à l'element (qui se traite) ainsi qu'il a plus de delta comme liquidité pour qu'il puisse preter à element 
                
                if p < gamma: 
                    # Une relation s'ajoute avec un taux gamma 
                    # et donc avec une probabilité gamma*dt.
                    # On condière dt=1
                    if k>0.5:
                        G.ajout_relation (j,i)
                    else:
                        G.ajout_relation (i,j)

            # prob       
            r=random.random() # tirer un nombre aléatoire entre 0 et 1
            r2=random.random()
            if G.graphe[i][0]!=[] and G.graphe[i][1]!=[]: # i a déjà prêté de l'argent
                d1 = random.randint(0,len(G.graphe[i][0])-1)
                d2 = random.randint(0,len(G.graphe[i][1])-1)
                j1 = G.graphe[i][0][d1] # i a prêté à j
                j2 = G.graphe[i][1][d2] # j a prêté à i
                if G.graphe[j1][1]!=[] and G.graphe[j2][0]!=[]:
                    if (r<lamda):
                        if r2>0.5:
                            if i in G.graphe[j1][1]:
                                G.invest_reussi(i,j1)
                        else:
                            if i in G.graphe[j2][0]:
                                G.invest_reussi(j2,i)
                        
            #divulgation de l'information  
            u = random.random()
            if u < nu:
                c_etoile= ( len(G.graphe[i][0]) + G.graphe[i][2] + 1 ) / ( len(G.graphe[i][1]) + 1 ) 
                if (c > c_etoile) and ( G.graphe[i][1]!=[]):
                #(G.graphe[i]!=[[],[],G.graphe[i][2]]) :
                    for j in G.graphe[i][1]:
                        if ( i in G.graphe[j][0]):
                            G.foreclose(j,i)
                G.graphe[i]=[[],[],G.graphe[i][2]]
            else:
                continue
    nombre_aretes_final=len(arete(G.graphe))
    densité_finale=nombre_aretes_final/ nb_arretes_initiale       
    return G.graphe,liste_de_connectivité,temps,densité_finale
lamda=0.4
gamma=0.99
nu=0.4
durée=100
c=0.5
liste_de_conectivité=dynamique (G, c, gamma,lamda,nu,durée)[1]
temps=dynamique (G, c, gamma,lamda,nu,durée)[2]
#plt.plot(temps,liste_de_conectivité)
#plt.show()
liste_des_C=np.linspace(0,1,101)

liste_connectivité2=[dynamique (G, c, gamma,lamda,nu,durée)[3]for c in liste_des_C]
plt.plot(liste_des_C,liste_de_conectivité)
plt.ylabel('nombre de relation')
plt.xlabel('c')
plt.title('variation de la densité du graphe en fonction du c (gamma=0.9 )')
plt.show()

