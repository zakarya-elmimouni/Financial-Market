import numpy as np
import random
#on commence par une petite representation du pràblème
#c'est une representation simple qui necessite pas mal de developpement surtout qu'il manque des points que j'ai pas comprise

#graphe contient tous les agents et modélise notre réseau sous forme d'un graphe 
#les sommmets sont les agents,et ils sont liés aux autres agents à travers les aretes 
#graphe a la structure suivante {agent:[[liste des agents auquelsl'agent a emprunté],[liste des angents qui ont preté à notre agent],b_O]}
#delta est le montant de pret par defaut pour tout le monde <1
#je dois ajouter b_0 dans le graphe pour tout le monde
def arete(graphe):
    aretes=[]
    for element in graphe.keys():
        for voisin in graphe[element][0]:
            if (element,voisin) not in aretes:
                aretes.append((element,voisin))
        for voisin in graphe[element][1]:
            if (voisin,element) not in aretes:
                aretes.append((voisin,element))
    return  aretes
#cette fonction est un modèle statique de notre problème 
def fonction(graphe,c,b_0):
    """cette fonction rertourne le réseau (graphe) à l'état stationnaire + la densité à l'état stationnaire"""
    modification=1#si la boucle tourne et il n'y a pas de modification alors on est arrivé à l'équilibre et on doit récupérer la version finale de notre réseau(graphe)
    while modification!=0:
        modification=0
        for element in graphe.keys():
            if c*(len(graphe[element][1])+1)>len(graphe[element][0])+b_0+1 and graphe[element]!=[[],[]]:
                graphe[element]=[[],[]]
                for voisin in graphe[element][0]:
                    graphe[voisin][1].remove(element)
                for voisin in graphe[element][1]:
                    graphe[voisin][0].remove(element)
                modification=1
            else:
                continue
    return graphe
#voici notre graphe de réference 
graphe={1:[[2,3,7],[4,5,6,8]],2:[[3,5,8],[1,6,7]],3:[[4,5],[2,1,5,7]],4:[[1,7,8],[3,5,6]],5:[[1,3,4,6,7],[2,3,8]],6:[[2,4,1],[5,8]],7:[[3,2,8],[4,1,5]],8:[[6,5,1],[4,2,7]]}
#ce graphe necessite encore une améléoration au niveau du nombre des sommets et de relations
#un problème qui se pose c'est quelle b_0 prendre pour ce graphe
# on doit choisir une valeur de b_0 qui dépend de la taille du graphe mais qui ne va pas biaiser la condition
#la conditoin est c*(len(graphe[element][1])+1)>len(graphe[element][0])+b_0+1

def graph_convenable(graphe):
    for element in graphe.keys():
        for voisin in graphe[element][0]:
            if element not in graphe[voisin][1]:
                return False
        for voisin in graphe[element][1]:
            if element not in graphe[voisin][0]:
                return False
    return True
#print(fonction(graphe,5,10))
#après ça je dois penser à comment je vais insérer la variable gamma qui modélise le taux de création d'un lien
#avec gamma on peut avoir un réseau dynamique 
#lam=4
#a=np.random.poisson(5)
#At rate gamma, each agent i takes out a loan from agent j, selected at random from the pool of other investors.
#This implies (ℓi, bi) → (ℓi + 1, bi) and (ℓj , bj) → (ℓj , bj + 1).
#essayons de développer la fonction implémentée précédemment pour avoir un modèle dynamique
def fonction_1(graphe,c,b_0,gamma,lamda,dt,delta):
    #je vais définir un dictionnaire des voisins
    nb_aretes_initial=len(arete(graphe))
    voisins={}
    #ajout du b_0 au graphe de tous les agents
    for element in graphe.keys():
        graphe[element].append(b_0)
    print(graphe)
    for element in graphe.keys():
        voisin_element=graphe[element][0]+graphe[element][1]
        voisin_element=set(voisin_element)
        voisin_element=list(voisin_element)
        voisins[element]=voisin_element
    modification=1
    while modification!=0:
        modification=0
        noeuds=list(graphe.keys())
        for element in noeuds:
            a=random.random()
            b=random.randint(0,len(noeuds)-1)#on recupère un indice aléatoire d'un voisin
            #attention tu dois recupérer un element aléatoire de tous les agents
            element_aléatoire=noeuds[b]
            if element_aléatoire!=element and element_aléatoire not in graphe[element][1] and graphe[element_aléatoire][2]>=delta:
                if a>=gamma*dt:
                    graphe[element][1].append(element_aléatoire)
                    graphe[element][2]=graphe[element][2]+delta
                    graphe[element_aléatoire][0].append(element)
                    graphe[element_aléatoire][2]=graphe[element_aléatoire][2]-delta
            r=random.random()
            if graphe[element][0]!=[]:
                d=random.randint(0,len(graphe[element][0])-1)
                element_aléatoire2=graphe[element][0][d]
                if graphe[element_aléatoire2][1]!=[] and graphe[element][2]>=delta:
                    if r>=lamda*dt:
                        graphe[element][0].remove(element_aléatoire2)#dégradation du lien
                        graphe[element][2]=graphe[element][2]-delta
                        graphe[element_aléatoire2][1].remove(element)
                        graphe[element_aléatoire2][2]=graphe[element_aléatoire2][2]+delta
            if c*(len(graphe[element][1])+1)>len(graphe[element][0])+b_0+1 and graphe[element]!=[[],[]]:
                graphe[element]=[[],[]]
                for voisin in graphe[element][0]:
                    graphe[voisin][1].remove(element)
                for voisin in graphe[element][1]:
                    graphe[voisin][0].remove(element)
                modification=1
            else:
                continue
    nb_aretes_final=len(arete(graphe))
    densité=nb_aretes_final/nb_aretes_initial
    return graphe,densité
print(graph_convenable(graphe),fonction_1(graphe,1,1,0.01,0.015,0.1,0.3))# un petit teste



