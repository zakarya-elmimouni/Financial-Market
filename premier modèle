import numpy as np
import random
#on commence par une petite representation du pràblème
#c'est une representation simple qui necessite pas mal de developpement surtout qu'il manque des points que j'ai pas comprise

#graphe contient tous les agents et modélise notre réseau sous forme d'un graphe 
#les sommmets sont les agents,et ils sont liés aux autres agents à travers les aretes 
#graphe a la structure suivante {agent:[[liste des agents auquelsl'agent a emprunté],[liste des angents qui ont preté à notre agent]]}
def arete(graphe):
    aretes=[]
    for element in graphe.keys():
        for voisin in graphe[element][0]:
            if (element,voisin) not in aretes:
                aretes.append((element,voisin))
        for voisin in graphe[element][1]:
            if (voisin,element) not in aretes:
                aretes.append((voisin,element))
    return  aretes
def fonction(graphe,c,b_0):
    """cette fonction rertourne le réseau (graphe) à l'état stationnaire + la densité à l'état stationnaire"""
    modification=1#si la boucle tourne et il n'y a pas de modification alors on est arrivé à l'équilibre et on doit récupérer la version finale de notre réseau(graphe)
    while modification!=0:
        modification=0
        for element in graphe.keys():
            if c*(len(graphe[element][1])+1)>len(graphe[element][0])+b_0+1 and graphe[element]!=[[],[]]:
                graphe[element]=[[],[]]
                for voisin in graphe[element][0]:
                    graphe[voisin][1].remove(element)
                for voisin in graphe[element][1]:
                    graphe[voisin][0].remove(element)
                modification=1
            else:
                continue
    return graphe
graphe={1:[[2,3,7],[4,5,6]],2:[[3,5,8],[1,6,7]],3:[[4,5],[2,1,5,7]],4:[[1,7,8],[3,5,6]],5:[[1,3,4,6,7],[2,3,8]],6:[[2,4,1],[5,8]],7:[[3,2,8],[4,1,5]],8:[[6,5],[4,2,7]]}
def graph_convenable(graphe):
    for element in graphe.keys():
        for voisin in graphe[element][0]:
            if element not in graphe[voisin][1]:
                return False
        for voisin in graphe[element][1]:
            if element not in graphe[voisin][0]:
                return False
    return True
#print(fonction(graphe,5,10))
#après ça je dois penser à comment je vais insérer la variable gamma qui modélise le taux de création d'un lien
#avec gamma on peut avoir un réseau dynamique 
#lam=4
#a=np.random.poisson(5)
#At rate gamma, each agent i takes out a loan from agent j, selected at random from the pool of other investors.
#This implies (ℓi, bi) → (ℓi + 1, bi) and (ℓj , bj) → (ℓj , bj + 1).
#essayons de développer la fonction implémentée précédemment
def fonction_1(graphe,c,b_0,gamma,lamda):
    #je vais définir un dictionnaire des voisins
    nb_aretes_initial=len(arete(graphe))
    voisins={}
    for element in graphe.keys():
        voisin_element=graphe[element][0]+graphe[element][1]
        voisin_element=set(voisin_element)
        voisin_element=list(voisin_element)
        voisins[element]=voisin_element
    modification=1
    while modification!=0:
        modification=0
        noeuds=list(graphe.keys())
        for element in noeuds:
            a=np.random.poisson(gamma)
            b=random.randint(0,len(noeuds)-1)#on recupère un indice aléatoire d'un voisin
            #attention tu dois recupérer un element aléatoire de tous les agents
            element_aléatoire=noeuds[b]
            if element_aléatoire!=element and element_aléatoire not in graphe[element][1]:
                if a>=gamma:
                    graphe[element][1].append(element_aléatoire)
                    graphe[element_aléatoire][0].append(element)
            r=np.random.poisson(lamda)
            if graphe[element][0]!=[]:
                d=random.randint(0,len(graphe[element][0])-1)
                element_aléatoire2=graphe[element][0][d]
                if graphe[element_aléatoire2][1]!=[]:
                    if r>=lamda:
                        graphe[element][0].remove(element_aléatoire2)#dégradation du lien 
                        graphe[element_aléatoire2][1].remove(element)
            if c*(len(graphe[element][1])+1)>len(graphe[element][0])+b_0+1 and graphe[element]!=[[],[]]:
                graphe[element]=[[],[]]
                for voisin in graphe[element][0]:
                    graphe[voisin][1].remove(element)
                for voisin in graphe[element][1]:
                    graphe[voisin][0].remove(element)
                modification=1
            else:
                continue
    nb_aretes_final=len(arete(graphe))
    densité=nb_aretes_final/nb_aretes_initial
    return graphe,densité
print(graph_convenable(graphe),fonction_1(graphe,0.9,6,0.5,0.5))# un petit teste



