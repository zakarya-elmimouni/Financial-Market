import numpy as np
import random
#on commence par une petite representation du pràblème
#c'est une representation simple qui necessite pas mal de developpement surtout qu'il manque des points que j'ai pas comprise

#graphe contient tous les agents et modélise notre réseau sous forme d'un graphe 
#les sommmets sont les agents,et ils sont liés aux autres agents à travers les aretes 
#graphe a la structure suivante {agent:[[liste des agents auquelsl'agent a emprunté],[liste des angents qui ont preté à notre agent]]}
def fonction(graphe,c,b_0):
    modification=1#si la boucle tourne et il n'y a pas de modification alors on est arrivé à l'équilibre et on doit récupérer la version finale de notre réseau(graphe)
    while modification!=0:
        modification=0
        for element in graphe.keys():
            if c*(len(graphe[element][1])+1)>len(graphe[element][0])+b_0+1 and graphe[element]!=[[],[]]:
                graphe[element]=[[],[]]
                for voisin in graphe[element][0]:
                    graphe[voisin][1].remove(element)
                for voisin in graphe[element][1]:
                    graphe[voisin][0].remove(element)
                modification=1
            else:
                continue
    return graphe
graphe={1:[[2,3],[4]],2:[[3],[1]],3:[[4],[2,1]],4:[[1],[3]]}
#print(fonction(graphe,5,10))
#après ça je dois penser à comment je vais insérer la variable gamma qui modélise le taux de création d'un lien
#avec gamma on peut avoir un réseau dynamique 
#lam=4
#a=np.random.poisson(5)
#At rate gamma, each agent i takes out a loan from agent j, selected at random from the pool of other investors.
#This implies (ℓi, bi) → (ℓi + 1, bi) and (ℓj , bj) → (ℓj , bj + 1).
#essayons de développer la fonction implémentée précédemment
def fonction_1(graphe,c,b_0,gamma,lamda):
    #je vais définir un dictionnaire des voisins
    voisins={}
    for element in graphe.keys():
        voisin_element=graphe[element][0]+graphe[element][1]
        voisin_element=set(voisin_element)
        voisin_element=list(voisin_element)
        voisins[element]=voisin_element
    modification=1
    while modification!=0:
        modification=0
        for element in graphe.keys():
            a=np.random.poisson(gamma)
            b=random.randint(0,len(voisins[element])-1)#on recupère un indice aléatoire d'un voisin
            #attention tu dois recupérer un element aléatoire de tous les agents
            if a>=gamma:
                graphe[element][1].append(voisins[element][b])
                graphe[voisins[element][b]][0].append(element)
            c=np.random.poisson(lamda)
            d=random.randint(0,len(graphe[element][0])-1)
            if c>=lamda:
                graphe[element][0].remove(graphe[element][0][d])#dégradation du lien 
                graphe[voisins[element][d]][1].remove(element)
                
            if c*(len(graphe[element][1])+1)>len(graphe[element][0])+b_0+1 and graphe[element]!=[[],[]]:
                graphe[element]=[[],[]]
                for voisin in graphe[element][0]:
                    graphe[voisin][1].remove(element)
                for voisin in graphe[element][1]:
                    graphe[voisin][0].remove(element)
                modification=1
            else:
                continue
    return graphe
print(fonction_1(graphe,10,10,1))# un petit teste

def aretes(graphe):
    aretes=[]
    for element in graphe.keys():
        for voisin in graphe[element][0]:
            if (element,voisin) not in aretes:
                aretes.append((element,voisin))
        for voisin in graphe[element][1]:
            if (voisin,element) not in aretes:
                aretes.append((voisin,element))
    return  aretes

